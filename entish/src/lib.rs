//! **This crate is early work in progress!**  It should not be used yet,
//! unless you are very adventurous!
//! # Entish
//! Entish is a crate that lets your write powerful declarative and
//! statically-typed tree structures and lets you focus on the business logic
//! of using them instead of having to reinvent the wheel and re-implement
//! standard primitives.
//! ## Example
//! ```
//! #[macro_use] extern crate entish;
//! use entish::prelude::*;
//!
//! /// Start by wrapping a tree-like enum declaration
//! /// with the `entish! { .. }` macro. This will trigger the
//! /// main code-generation process of the crate and is where
//! /// everything can be customized.
//! entish! {
//!     #[derive(Map, From, IntoResult)]
//!     #[entish(variants_as_structs)]
//!     enum Arithmetic {
//!         Plus {
//!             left: Self,
//!             right: Self
//!         },
//!         Times {
//!             left: Self,
//!             right: Self
//!         },
//!         Just(i32)
//!     }
//! }
//!
//! /// Then add some dynamic indirection to allow for recursively
//! /// wrapping nodes in other nodes.
//! pub struct Expr(Arithmetic<Box<Self>>);
//! 
//! impl ArithmeticTree for Expr
//! {
//!     fn as_ref(&self) -> Arithmetic<&Self> {
//!         self.0.map(&mut |c| c.as_ref())
//!     }
//! }
//! /// After all of this we can do things like this
//! fn do_arithmetic(node: &Arithmetic<i32>) -> i32 {
//!     match *op {
//!         Arithmetic::Plus(Plus { left, right }) => left + right,
//!         Arithmetic::Times(Times { left, right }) => left * right,
//!         Arithmetic::Just(Just(v)) => v
//!     }
//! }
//! 
//! impl Expr
//! {
//!     fn compute_value(self) -> i32 {
//!         self.fold(&mut |op| do_arithmetic)
//!     }
//! }
//! ```
//! The code this generates is fully documented so you can run `cargo doc` to
//! to see exactly what this does. To see the documentation of the code that
//! this example would generate, see the [entish-test](https://docs.rs/entish-test) crate.
//! ## Usage
//! - To do.

use std::sync::Arc;

#[macro_use] extern crate entish_derive;
pub use entish_derive::{entish, generate, expr_match, unravel};

pub mod prelude;

/// A trait for types that allow for applying a closure `FnMut(I) -> O`
/// around an inner `I` and wrapping around the result. See the [provided
/// implementation](#foreign-impls) on `Vec<I>` for an example.
///
/// This trait is not meant to be used directly, but instead should be used
/// through the `.map` method implemented on types generated by Entish.
pub trait Map<'a, I: 'a, O: 'a> {
    /// The type obtained after applying a closure to an inner `I`.
    type OuterO: 'a;
    /// Apply the closure `f` to inner `I` and return a new instance
    /// like `Self` but wrapping around the output of type `O`.
    fn map<F>(&'a self, f: &mut F) -> Self::OuterO
    where
        F: FnMut(I) -> O;
}

pub trait MapOwned<I, O> {
    type OuterO;

    fn map_owned<F>(self, f: &mut F) -> Self::OuterO
    where
        F: FnMut(I) -> O;
}

impl<'a, I, O: 'a> Map<'a, &'a I, O> for Vec<I> {
    type OuterO = Vec<O>;
    #[inline]
    fn map<F>(&'a self, f: &mut F) -> Self::OuterO
    where
        F: FnMut(&'a I) -> O
    {
        self.iter().map(f).collect()
    }
}

impl<'a, I, O: 'a> Map<'a, &'a I, O> for Option<I> {
    type OuterO = Option<O>;
    #[inline]
    fn map<F>(&'a self, f: &mut F) -> Self::OuterO
    where
        F: FnMut(&'a I) -> O
    {
        self.as_ref().map(f)
    }
}

impl<I, O> MapOwned<I, O> for Vec<I> {
    type OuterO = Vec<O>;
    fn map_owned<F>(self, f: &mut F) -> Self::OuterO
    where
        F: FnMut(I) -> O
    {
        self.into_iter().map(f).collect()
    }
}

impl<I, O> MapOwned<I, O> for Option<I> {
    type OuterO = Option<O>;
    fn map_owned<F>(self, f: &mut F) -> Self::OuterO
    where
        F: FnMut(I) -> O
    {
        self.map(f)
    }
}

impl<'a, I: 'a, O: 'a> Map<'a, &'a I, O> for Arc<I> {
    type OuterO = Arc<O>;
    fn map<F>(&'a self, f: &mut F) -> Self::OuterO
    where
        F: FnMut(&'a I) -> O
    {
        Arc::new(f(self))
    }
}

impl<I: Clone, O> MapOwned<I, O> for Arc<I> {
    type OuterO = Arc<O>;
    fn map_owned<F>(self, f: &mut F) -> Self::OuterO
    where
        F: FnMut(I) -> O
    {
        Arc::new(f((*self).clone()))
    }
}

/// A trait for types that can convert to a `Result<O, E>`.
pub trait IntoResult<O, E> {
    fn into_result(self) -> std::result::Result<O, E>;
}

impl<O, E> IntoResult<Vec<O>, E> for Vec<Result<O, E>> {
    fn into_result(self) -> std::result::Result<Vec<O>, E> {
        self.into_iter().collect()
    }
}

impl<O, E> IntoResult<Option<O>, E> for Option<Result<O, E>> {
    fn into_result(self) -> std::result::Result<Option<O>, E> {
        self.transpose()
    }
}

/// A trait for types that can convert to an `Option<O>`.
pub trait IntoOption<O> {
    fn into_option(self) -> Option<O>;
}


impl<O> IntoOption<Vec<O>> for Vec<Option<O>> {
    fn into_option(self) -> Option<Vec<O>> {
        self.into_iter().collect()
    }
}

impl<O> IntoOption<O> for Option<O> {
    fn into_option(self) -> Option<O> {
        self
    }
}
